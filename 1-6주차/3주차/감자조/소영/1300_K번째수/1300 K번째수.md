# 1300 K번째수 G3

1. 알고리즘 분류

   - 이분탐색
   
2. 문제

   세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

   배열 A와 B의 인덱스는 1부터 시작한다.

3. 입력

   첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

4. 출력

   B[k]를 출력한다.

## 1. 내 풀이

1. 시간

   - 시간 초과

2. 이유 

   - 시간초과 날 것 같았지만 일단 돌려봤다

   - 이진탐색 분류에 들어가있길래 이진탐색을 생각해봤다.


3. 어려웠던 점 / 아쉬운 점

   - 이진탐색을 아는데도 적용하는게 쉽지 않았다. 여러가지 시각으로 생각해보는게 중요한 것 같다.

4. 코드

   ```python
   # 아무 생각 없이 코드를 날렸는데, 그냥 무식하게 나열하고 정렬해서 구한 건 당연히 시간초과
   # 이후 이진탐색을 시도해보려던 흔적
   import sys
   # input = sys.stdin.readline
   sys.stdin = open('input.txt', 'r')
   
   
   N = int(input())
   k = int(input())
   r = k
   l = 1
   while l <= r:
       cnt = 0
       m = (l+r)//2
       for i in range(1, N+1):
           
   
       break
   
   
   ```

   

   

## 2. 다른 사람 풀이

### 2.1 

1. 시간

   - 1092

2. 코드

   ```python
   N, K = int(input()), int(input())
   start, end = 1, K # k번째 수는 k보다 작거나 같다
   
   while start <= end:
       mid = (start + end) // 2 #중간값  구해서, 이 mid보다 작거나 같은 수를 tmp에 저장
       tmp = 0
       for i in range(1, N+1) : # 1부터 N까지 행 순회
           tmp += min(mid // i, N) # 하면서 mid 이하인 수 더함 
       if tmp >= K: # 해서 다 더한게 k보다 크거나 같으면
           ans = mid # ans = mid
           end = mid - 1 # end는 mid -1
       else:
           start = mid + 1 # 다 더한게 k보다 작으면 시작을 하나 올림
   print(ans)
   
   ```
   
   
   
3. 해설

   사실 처음 코드를 봤을 때는 아무리 봐도 이진탐색을 썼다는 점 외에는 이해하기 힘들어서 디버깅 돌리고, 다른 사람이 블로그에 포스팅해둔 것들을 보며 확인했다.

   - __k를 기준으로 세는게 아니라 mid보다 작은 수를 세는 것__ 이 생각 포인트인 것 같다.
   - mid 이하인 수의 개수(ans) < k 는 == k번째까wl

   ```
   예시
   3, 7
   mid = 4
     1 2 3 
   1 1 2 3
   2 2 4 6
   3 3 6 9
   
   1, 7, 4
   3 + 1 = 4
   
   2, 7, 4
   3 + 1 = 4
   
   3, 7, 5
   3 + 2 + 1 = 6
   
   4 7 5 
   3 + 2 + 1 = 6
   
   5 7 6
   3 + 3 + 2 = 8
   
   5 6 5
   3 + 2 + 1 = 6
   
   6 6 6
   3 + 3 + 2 = 8
   
   6 5 break
   ```

   

   

   

