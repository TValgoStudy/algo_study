# 15678_연세워터파크

deque으로 어떻게 푸는지 도저히 모르겠어서 그냥 찾아봤다.

제대로 푼 문제가 없다.



```python
from collections import deque

n, D = map(int,input().split())
stone = list(map(int,input().split()))

dp = [stone[0]]
Q = deque([(0, stone[0])]) # j, f(j)
for i in range(1, n):
    # stone[i] + max dp[j]; i-j <= D
    while Q and Q[0][0] < i-D: Q.popleft()
    dp.append(stone[i] + max(0, Q[0][1]))
    while Q and Q[-1][1] < dp[i]: Q.pop()
    Q.append((i, dp[i]))
print(max(dp))
```



### example

```
10 2
2 7 -5 -4 10 -5 -5 -5 30 -10
```

인덱스를 0부터 끝까지 이동하면서 현재 위치와 D 범위 내의 이전 위치에 있는 징검다리의 합 중 가장 큰 것을 계속해서 저장해나간다. 가장 큰 값은 deque에 남아있는 `Q[0][1]`에 있다. 인덱스를 이동하면서 최댓값도 계속 갱신한다.

맨 처음부터 확인하면,

index = 0

```
dp = [2]
deque([(0, 2)])
```

index = 1  => 7을 이전 값들과 비교 => 2 하나만 있음 => 더함

```
deque([(0, 2)])

dp = [2, 9]

deque([(1, 9)])  <== 2와 비교했을 때 더 크기 때문에 얘만 남김, 다음 계산에 사용
```

imdex = 2 => -5를 이전 값들과 비교 => 원래 2와 9가 가능 => 둘 중 더했을 때 더 값이 큰 걸로 추가

```
deque([(1, 9)])

dp = [2, 9, 4]

deque([(1, 9), (2, 4)]) <== 4와 9를 비교하면 9가 더 커서 (1, 9)를 남겨두고 (2, 4) 추가
```

index = 3 => -4를 이전 값들과 비교 => 원래 9와 4가 가능 => 둘 중 더했을 때 더 값이 큰 걸로 추가

```
deque([(1, 9), (2, 4)])

dp = [2, 9, 4, 5]

deque([(1, 9), (3, 5)]) <== (2, 4)의 4보다 (3, 5)의 5가 더 커서 (2, 4) 지우고 (3, 5) 추가
```

index = 4 => 10을 이전 값들과 비교 => 원래 4와 5가 가능 => 15가 최대값

```
deque([(1, 9), (3, 5)])
deque([(3, 5)]) <== (1, 9)는 처음에 인덱스 차이 제한(D)으로 사라짐

dp = [2, 9, 4, 5, 15]  <== 5에 현재 인덱스의 value 더함

deque([(4, 15)])  <== (3, 5)의 5보다 (4, 15)의 15가 더 크기 때문에 (4, 15)만 남김
```

index = 5 => -5를 이전 값들과 비교 => 원래 5와 15가 가능 => 10이 최대값

```
deque([(4, 15)])

dp = [2, 9, 4, 5, 15, 10]

deque([(4, 15), (5, 10)])  <== (4, 15)가 (5, 10)보다 크기 때문에 남겨둠
```

index = 6 => -5를 이전 값들과 비교 => 원래 15와 10이 가능 => 10이 최대값

```
deque([(4, 15), (5, 10)])

dp = [2, 9, 4, 5, 15, 10, 10]

deque([(4, 15), (5, 10), (6, 10)])
```

index = 7 => -5를 이전 값들과 비교 => 원래 10과 10이 가능 => 5가 최대

```
deque([(4, 15), (5, 10), (6, 10)])
deque([(5, 10), (6, 10)])  <== (4, 15)는 처음에 인덱스 차이 제한으로 사라짐

dp = [2, 9, 4, 5, 15, 10, 10, 5]

deque([(5, 10), (6, 10), (7, 5)])
```

index = 8 => 30을 이전 값들과 비교 => 원래 10과 5가 가능 => 40이 최대

```
deque([(5, 10), (6, 10), (7, 5)])
deque([(6, 10), (7, 5)])  <== (5, 10)은 처음에 인덱스 차이 제한으로 사라짐

dp = [2, 9, 4, 5, 15, 10, 10, 5, 40]

deque([(6, 10), (8, 40)])  <== (7, 5)보다 (8, 40)이 더 크므로 (8, 40)만 남김
```

index = 9 => -10을 이전 값들과 비교 => 원래 5와 40이 가능 => 30이 최대

```
deque([(6, 10), (8, 40)])
deque([(8, 40)])

dp = [2, 9, 4, 5, 15, 10, 10, 5, 40, 30]

deque([(8, 40), (9, 30)])
```



이제 dp에서 최댓값을 프린트하면 답이 된다.



