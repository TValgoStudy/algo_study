# 2493_탑



## 시간 초과 풀이

```python
# 500,000개의 이중 루프 => 시간초과

import sys
sys.stdin = open('input.txt')

N = int(input())
towers = list(map(int, input().split()))
answer = [0]*N
for i in range(len(towers)-1, 0, -1):
    for j in range(i-1, 0, -1):
        if towers[i] < towers[j]:
            answer[i] = j+1
            break

print(*answer)
```



## 틀린 풀이

```python
import sys
sys.stdin = open('input.txt')

N = int(input())
towers = list(map(int, input().split()))
answer = [0]*N
L = len(towers)
i = L-1 # 포인터
j = L-2 # 포인터2
tmp = towers[i]
while i >= 0:
    if tmp <= towers[j]:
        for k in range(j+1, i+1):
            answer[k] = j+1
        i -= 1
        j -= 1
        tmp = towers[i]
    elif tmp > towers[j]:
        j -= 1

        if j == -1:
            answer[i] = 0
            i -= 1
            j = i-1
            tmp = towers[i]

print(*answer)
```



## 정답(stack 사용)

```python
import sys
sys.stdin = open('input.txt')

N = int(input()) # 탑의 수

towers = list(map(int, input().split()))

# 맨 오른쪽부터 순서대로 스택에 쌓는다.
# 새로운 탑의 높이를 마지막 원소와 비교하여 새로운 탑이 더 크면 꺼낸다.
ans = [0] * N
stack = []
L = len(towers)
stack.append((L-1, towers[-1])) # 초기값(가장 오른쪽 탑의 번호와 높이)
for i in range(L-2, -1, -1): # 역순
    while stack[-1][1] < towers[i]:
        idx, tall = stack.pop()
        ans[idx] = i+1
        if len(stack) == 0:
          break
    stack.append((i, towers[i]))

print(*ans)
```

스택을 사용하면 너무 간단하다.



